#  C Programming

이 저장소는 C 언어 학습을 위한 저장소입니다. 각 장에서는 핵심 개념을 학습하고, 실습 코드를 통해 직접 구현합니다.

---

 ##  CHAPTER 12: 파일 입출력

 - 파일 모드
   "r" 읽기 모드로 파일을 연다.
   "w" 쓰기 모드로 파일을 생성함. 만약 파일이 존재하지 않으면 파일이 생성됨. 파일이 이미 존재하면 기존의 내용이 지워짐.
   "a" 추가 모드로 파일을 연다. 만약 똑같은 이름의 기존의 파일이 있으면 데이터가 파일의 끝에 추가됨. 파일이 없으면 새로운 파일을 만든다.

 - 파일을 쓰기 모드로 열었다가 닫기
```c
#include<stdio.h>

int main(void)
{
  FILE *fp = NULL;

  fp = fopen("sample.txt", "w");

  if (fp == NULL)
     printf("파일 열기 실패\n");
  else
     printf("파일 열기 성공\n");

  fclose(fp);
  return 0;
}
```
 - 형식화된 입출력
   정수 10은 파일에도 문자열 "10"으로 변환하여 저장함. 읽을 때는 반대 상황이 된다. 파일에 저장된 문자열 "10"을 정수 10으로 변환시켜야 함.
   이런 종류의 입출력을 형식화된 입출력이라고 함. 형식화된 입출력은 프로그래머가 특정 형식을 지정하고 이 형식으로 파일에 입출력을 하는 것.
   형식화된 입출력은 fprintf()와 fscanf()을 이용하여 이루어짐.

 - 이진 파일
   이진 파일(binary file)은 데이터가 직접 저장되어 있는 파일임. 즉 정수 123456은 문자열로 변환되지 않고 이진수 상태로 파일에 기록되는 것임.
   이진 파일의 장점은 효율성이다. 텍스트 파일에서 숫자 데이터를 읽으려면 먼저 문자를 읽어서 fscanf()와 같은 함수를 사용하여 변환하여야 하는데
   이 과정은 시간이 많이 걸리며 비효율적임. 이진 파일을 사용하면 이러한 변환 과정이 필요 없이 바로 숫자 데이터를 읽을 수 있으며 텍스트 파일에
   비하여 저장 공간도 더 적게 차지함.

 - 이진 파일 사용하기
   이진 파일을 생성하려면 fopen()에서 파일 모드에 "b"를 붙이면 된다. 즉 읽기 전용으로 파일을 열려면 파일 모드로 "rb"를 사용함. 쓰기 전용으로 파일
   을 열려면 파일 모드로 "rb"를 사용함.
   ```c
   FILE *fp1 = fopen("binary.bin", "rb"); // 읽기 전용
   FILE *fp2 = fopen("binary.bin", "wb"); // 쓰기 전용
   ```
 - 정수 한개를 이진 파일에 저장하려면 다음과 같이 적으면 된다.
   ```c
   int x = 123456;
   fwrite(&x, sizeof(int), 1, fp);
   ```
 - 반대로 이진 파일에서 정수 1개를 읽는 문장
   ```
   int x;
   fread(&x, sizeof(int), 1, fp);
   ```
 - 순차 접근과 임의 접근
   데이터의 파일을 처음부터 순차적으로 읽거나 기록하는 것이 순차 접근 방법이라고 함. 이러한 방법은 한번 읽은 데이터를 다시 읽으려면 현재의 파일을
   닫고 파일을 다시 열어야 함. 또한 앞부분을 읽지 않고 중간이나 마지막으로 건너뛸 수 없음. 또 다른 파일 입출력 방법으로 임의 접근 방법이 있음.
   임의 접근 방법은 파일의 어느 위치에서든지 읽기와 쓰기가 가능함.
 - 임의 접근의 원리
   모든 파일에는 파일 포인터 라는 것이 존재함. 파일 포인터는 64비트의 값으로 읽기와 쓰기 동작이 현재 어떤 위치에서 이루어지는지 나타낸다.
   새 파일이 만들어지게 되면 파일 포인터는 값이 0이고 이것은 파일의 시작 부분을 가리킨다. 기존의 파일의 경우, 추가 모드에서 열렸을 경우에는
   파일의 끝이 되고, 다른 모드인 경우에는 파일의 시작 부분을 가리킨다.
 - 파일 포인터 관련 함수
   fseek() 함수를 이용하면 위치 표시자를 보다 정밀하게 제어할 수 있음. fseek()는 위치표시자의 값을 원하는 값으로 설정함.

 ## CHAPTER 13: 동적 메모리
 - 동적 할당 메모리란?
   프로그램이 메모리를 할당받는 방법에는 정적(static)과 동적(dynamic)의 두 가지 방법이 있음. 정적 메모리 할당이란 프로그램이 시작되기 전에
   미리 정해진 크기의 메모리를 할당 받는 것.
   예를 들어 아래와 같이 배열을 선언하면 정적으로 메모리를 할당받는 것
```c
int sarray[10];
```
 - 동적 메모리 할당
   동적 메모리를 할당하는 가장 기본적인 함수인 malloc()은 헤더 파일<stdlib.h>에 원형이 정의되어 있으며 바이트 단위로 메모리를 할당함.

 - 동적 메모리 사용
   동적 메모리 공간은 이름이 없음. 동적 메모리 공간은 오직 포인터를 사용하여 사용할 수 있음. 반환된 포인터를 통하여 메모리 블록에 데이터를
   쓰고 읽을 수 있음. *pi = 'a'; 문장을 수행하면 동적으로 할당된 공간에 문자 'a'가 저장됨.
```c
*p = 'a';
```
 - 동적 메모리 반납
   free()는 동적으로 할당되었던 메모리 블록을 시스템에 반납함. 다음과 같은 함수 원형을 가지며 여기서 ptr은 malloc()이나 calloc()을 이용하여
   동적 할당된 메모리를 가리키는 포인터임.
```c
void free(void *ptr)

include<stdlib.h>

char *p;
p = (char *)malloc(100);

free(p);
```

 - 동적 메모리에 1,2,3,4,5를 저장하는 문장은 다음과 같이 반복 구문으로 작성 가능
```c
int i;
for(i = 0; i < 5; i++){
    pi[i] = i+1;
}
```
 ## CHAPTER 14:  전처리기와 분할 컴파일 

 - 전처리기란?
   본격적으로 컴파일하기에 앞서 소스 파일을 처리하는 컴파일러의 한 부분임. 전처리기는 보통 컴파일러에 포함되어 있고 자동으로 실행되며
   컴파일러의 하나의 요소로 취급됨.
   전처리기에서는 몇 가지의 전처리기 지시자들을 처리함. 이들 지시자들은 # 기호로 시작함. 우리가 헤더 파일을 포함하기 위해 사용하였던
   #include가 바로 전처리기 지시어임.
 ```c
소스파일 -> 전처리기 -> 임시파일 -> 컴파일러 -> 오브젝트 파일
 ```
 - 전처리기 지시자
```c
#define            // 매크로 정의
#include           // 파일 포함
#undef             // 매크로 정의 해제
#if, #else, #endif // 조건에 따른 컴파일
#ifdef, #endif     // 매크로가 정의되어 있는 경우 컴파일
#ifndef, #endif    // 매크로가 정의되어 있지 않은 경우 컴파일
#line              // 행번호 출력
```
 - 단순 매크로
   define 지시자를 이용하면 숫자 상수에 의미 있는 이름을 부여할 수 있음. #define문을 이용하여 숫자 상수를 기호 상수로 만든 것을 단순
   매크로라고 함.
   예를 들어 다음 문장은 100이라는 정수 상수를 MAX_SIZE 라는 매크로로 표기하는 것
```C
#define MAX_SIZE 100
```
 - define과 typedef의 차이점
   define을 이용하여 다음과 같이 unsigned char를 다시 정의하여 사용 가능
```c
#define uchar unsigned char
```
   이것은 얼핏 다음과 같은 typedef 문과 비슷함.
```c
typedef unsigned char UCHAR;
```
   typedef는 컴파일러에 의해 처리되지만 define은 전처리기에 의해 처리가 됨. define은 기계적인 텍스트 변경임. 즉 UCHAR은 전처리기에 의해
   모두 unsigned char로 바뀌어 컴파일됨. 하지만 typedef는 사용자가 새로운 자료형을 정의한 것이므로 컴파일러가 컴파일 내내 그 의미를 알고 있음.
   따라서 가능하면 새로운 자료형을 정의할 때는 typedef를 사용하는 편이 좋음. 

 - &&을 and로 바꾸기
   C언어에서는 논리합이나 논리곱을 나타낼 때, &&이나 ||를 사용함. 전처리기를 사용하면 이것을 파이썬처럼 AND와 OR로 바꿀 수 있음.
```c
#define and &&
#define or ||
```
 - 함수 매크로
   매크로가 함수처럼 매개 변수를 가지는 것임. 함수 매크로를 사용하면 함수와 유사한 매크로를 작성할 수 있음.
```c
형식 : #define 매크로(인수1, 인수2, ....) 텍스트
설명 : 매크로를 찾아서 텍스트로 바꿈. 인수1, 인수2는 함수의 인수처럼 동작.
#define SQUARE(x) ( (x) * (x) )
#define MAX(x,y) ( (x) > (y) ) ? (x) : (y)
#define MIN(x,y) ( (x) < (y) ) ? (x) : (y)
#define HALF(x) ( (x)/2 )

// 주어진 수의 제곱을 구하는 매크로

#define SQUARE(x) ((x) * (x))
```
 - 함수 매크로 정의시 주의할 점
   매개 변수가 기계적으로 대치되기 때문에 매크로를 정의하는 경우에 반드시 매개 변수들을 괄호로 묶어야 함.
 - 함수 매크로 vs 함수
   매크로를 함수 대신 사용하면 어떤 장점과 단점이 있는가? 함수 매크로의 장점은 함수에 비해 수행 속도가 빠르다. 함수 매크로는 함수 호출이
   아니라 코드가 그 위치에 삽입되는 것이기 때문에 함수 호출의 복잡한 단계를 거칠 필요가 없음. 함수 호출을 하기 위해서는 인수와 복귀 주소를
   시스템 스택에 저장하는 복잡한 절차들이 필요한데 함수 매크로는 이러한 절차들이 전혀 필요없음.
```c
// SQUARE(x)를 매크로로 정의
#define SQUARE(x) ((x) * (x))

// SQUARE(x)를 함수로 구현하면 다음과 같음.
int SQUARE(int x)
{
  return x*x;
}
```
 - 함수 매크로의 단점
   코드의 길이를 어느 한도 이상 길게 할 수 없음. 또한 함수 매크로가 발견될 때마다 정의된 코드가 삽입되므로 전체 소스의 길이가 길어짐.
   따라서 함수 매크로를 사용할 것인지 함수를 사용할 것인지 문제는 프로그램의 크기와 실행 속도 중에서 어떤 것이 더 중요한지 따져야함.
   다음과 같은 간단한 기능은 함수보다는 함수 매크로를 사용하는 편이 낫다.
```c
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#define ABS(x) ((x) > 0 ? (x) : -(X))
```
 - #ifdef, #endif
   ifdef는 조건부 컴파일을 지시하는 전처리 지시자임. 조건부 컴파일이란 어떤 조건이 만족되는 경우에만 지정된 소스 코드 블록을 컴파일하는 것.
   ifdef는 ifdef다음에 있는 매크로를 검사하여 매크로가 정의되어 있으면 if와 endif 사이에 있는 모든 문장들을 컴파일함.
   그렇지 않으면 문장들은 컴파일되지 않아서 실행 코드에 포함되지 않음.
```c
#ifdef DEBUG
   printf("x=%d, y=%d\n", x, y);
#endif
```
 - 다중 소스 파일
   소스 파일을 여러 개를 만드는 이유는 서로 관련된 함수들을 모아 독립적인 소스 파일에 저장시켜 놓으면 다음에 재사용할 수 있기 때문임.
 - extern 키워드
   다중 소스 파일의 경우, 하나의 프로그램에 여러 개의 소스 파일이 존재함. 지역 변수의 경우 어차피 정의된 함수를 벗어나면 사용이 불가능.
   전역 변수가 정의된 소스 파일 이외의 다른 소스파일에서 사용하려면 외부 변수로 선언하는 것.
```c
extern double gx, gy;
```
   외부 변수로 선언되면 power.c에서는 gx, gy를 사용할 수 있음. extern 키워드는 변수가 외부에 선언되어 있다는 것을 컴파일러에게 알려주는 
   역할을 함. extern으로 선언된 변수는 전역 변수처럼 소스 파일의 모든 함수에서 사용 가능 

 - 프로그램 인수
   main()도 함수이므로 매개 변수와 반환 값을 가질 수 있음.
```c
int main(int argc, char *argv[])
{

}
```
 위의 형태에서는 두 개의 매개 변수가 선엄됨. argc는 프로그램 실행 시 전달되는 인수의 개수를 의미함. argv는 문자열의 형태로 안에 있는 단어들
 을 전달함. argv는 문자형 포인터의 배열임을 유의할것.
 
   
 



   
